<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Javidan Guard — Map</title>

  <!-- Umami (optional) -->
<script defer src="https://cloud.umami.is/script.js" data-website-id="e44ab596-9616-4149-944c-cfa4fa4801cf"></script>
  <style>
    html, body { height:100%; margin:0; }
    #app { display:grid; grid-template-columns: 1fr 360px; height:100%; }
    #map { width:100%; height:100%; }
    #panel { padding:12px; border-left:1px solid #ddd; font:14px system-ui, sans-serif; overflow:auto; }
    button, input, textarea { padding:8px; margin:6px 0; width:100%; }
    .recovery { word-break: break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted { color:#666; font-size:12px; }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    .badge { display:inline-block; min-width:20px; padding:2px 6px; border-radius:10px; background:#333; color:#fff; font-size:12px; text-align:center; }
    #chatList { border:1px solid #ddd; border-radius:6px; padding:8px; height:220px; overflow:auto; background:#fafafa; }
    .msg { margin:4px 0; padding:4px 6px; border-radius:6px; background:#fff; border:1px solid #eee; }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    <div id="panel">
      <h3>Status</h3>
      <div id="loginState" class="muted">Checking…</div>

      <h3>Private Login</h3>
      <button id="btnCreate" type="button">Create private account</button>
      <div id="created" style="display:none">
        <div class="muted">Save this recovery phrase to login on another device:</div>
        <div id="recovery" class="recovery"></div>
      </div>
      <input id="inpRecovery" placeholder="Paste your recovery phrase" />
      <button id="btnRecover" type="button">Recover account</button>
      <button id="btnLogout" type="button" style="display:none">Log out</button>
      <div id="authMsg" class="muted"></div>

      <hr/>

      <h3>My Area & Group</h3>
      <div class="muted">Click the map to pick your area (hex). Set your group size, then “Save Profile”.</div>
      <div class="row">
        <input id="groupSize" type="number" min="1" max="9999" step="1" placeholder="Group size" />
      </div>
      <div class="row">
        <input id="areaCell" placeholder="Selected area (H3)" readonly />
        <button id="btnUseSelected" type="button">Use selected</button>
      </div>
      <button id="btnSaveProfile" type="button">Save Profile</button>
      <div id="profileMsg" class="muted"></div>

      <hr/>

      <h3>Area Chat <span id="badge" class="badge" style="display:none">0</span></h3>
      <div id="chatList"></div>
      <textarea id="chatInput" rows="3" placeholder="Type a message…"></textarea>
      <button id="btnSendChat" type="button">Send</button>
      <div id="chatMsg" class="muted"></div>

      <hr/>

      <h3>Map Add</h3>
      <div class="muted">Click the map to select a hex. Then set a value.</div>
      <input id="valInput" type="number" step="0.01" placeholder="Value (e.g. 1.0)" />
      <button id="btnAdd" type="button" disabled>Add to selected hex</button>
      <div id="status" class="muted"></div>
    </div>
  </div>

  <script>
  (async function () {
    // ---------- helpers ----------
    const $ = id => document.getElementById(id);
    const set = (id, t) => { const el=$(id); if(el) el.textContent=t||''; };
    const show = (id, on) => { const el=$(id); if(el) el.style.display = on ? '' : 'none'; };
    const disable = (id, on) => { const el=$(id); if(el) el.disabled = !!on; };
    await new Promise(r => (document.readyState === 'complete' ? r() : window.addEventListener('load', r)));

    function loadCss(urls) {
      // add first working CSS; ignore errors
      for (const url of urls) {
        const l = document.createElement('link');
        l.rel = 'stylesheet'; l.href = url;
        document.head.appendChild(l);
      }
    }
    function loadScriptOnce(urls, globalKey) {
      return new Promise(async (resolve, reject) => {
        let lastErr;
        for (const url of urls) {
          if (window[globalKey]) return resolve(window[globalKey]);
          try {
            await new Promise((res, rej) => {
              const s = document.createElement('script');
              s.src = url; s.async = true; s.defer = true;
              s.onload = () => res();
              s.onerror = () => rej(new Error('Fail ' + url));
              document.head.appendChild(s);
            });
            if (window[globalKey]) return resolve(window[globalKey]);
          } catch (e) { lastErr = e; }
        }
        reject(lastErr || new Error('Failed to load ' + globalKey));
      });
    }

    // ---------- load Leaflet + h3 with fallbacks ----------
    loadCss([
      'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
      'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css'
    ]);
    try {
      await loadScriptOnce([
        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
        'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js'
      ], 'L');
      await loadScriptOnce([
        'https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.min.js',
        'https://cdn.jsdelivr.net/npm/h3-js@4.1.0/dist/h3-js.umd.min.js'
      ], 'h3');
    } catch (e) {
      set('status', 'Map libs failed to load. Open DevTools → Network to see which CDN is blocked.');
      console.error(e);
      return;
    }

    // ---------- auth ----------
    let selectedHex = null, currentArea = null, currentUid = null;

    async function refreshSessionUI() {
      try {
        const r = await fetch('/api/auth/me');
        const out = await r.json();
        const logged = !!out.loggedIn;
        currentUid = out.userId || null;
        set('loginState', logged ? 'Logged in' : 'Not logged in');
        show('btnLogout', logged);
        disable('btnCreate', logged);
        disable('btnAdd', (!logged || !selectedHex));
        return logged;
      } catch { set('loginState','Unknown'); return false; }
    }

    $('btnCreate').onclick = async () => {
      set('authMsg','…');
      const r = await fetch('/api/auth/create', { method:'POST' });
      const out = await r.json();
      if (out.ok && !out.already) { $('created').style.display='block'; set('recovery', out.recovery); set('authMsg','Account created. Save the phrase.'); }
      else if (out.ok && out.already) set('authMsg','You are already logged in.');
      else set('authMsg','Failed: '+(out.message||'unknown'));
      await refreshSessionUI();
    };
    $('btnRecover').onclick = async () => {
      set('authMsg','…');
      const recovery = $('inpRecovery').value.trim();
      const r = await fetch('/api/auth/recover', {
        method:'POST', headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ recovery })
      });
      const out = await r.json();
      set('authMsg', out.ok ? 'Recovered. You are logged in.' : ('Failed: '+(out.message||'unknown')));
      await refreshSessionUI();
    };
    $('btnLogout').onclick = async () => { await fetch('/api/auth/logout', { method:'POST' }); set('authMsg','Logged out.'); await refreshSessionUI(); };

    // ---------- map ----------
    const map = L.map('map', { doubleClickZoom:false }).setView([32.4279, 53.6880], 5);
    // Try two tile servers (OSM → Carto) in case one is slow/blocked
    const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'&copy; OpenStreetMap' });
    tiles.on('tileerror', () => {
      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
        attribution:'&copy; OpenStreetMap &copy; CARTO'
      }).addTo(map);
    });
    tiles.addTo(map);

    const layerAgg = L.layerGroup().addTo(map);
    const H3_RES = 7;

    function hexPoly(h, fillOpacity=0.35) {
      const coords = h3.cellToBoundary(h, true).map(([lat,lng]) => [lat,lng]);
      const poly = L.polygon(coords, { weight:1, fillOpacity });
      poly.on('click', (e)=>{ e.originalEvent?.preventDefault?.(); selectedHex = h; $('areaCell').value = h; updateSel(); });
      return poly;
    }
    function updateSel() {
      const canAdd = (!!selectedHex) && ($('btnLogout').style.display !== 'none');
      disable('btnAdd', !canAdd);
      set('status', selectedHex ? `Selected: ${selectedHex}` : '');
    }
    map.on('click', (e)=>{ selectedHex = h3.latLngToCell(e.latlng.lat, e.latlng.lng, H3_RES); $('areaCell').value = selectedHex; updateSel(); });

    // profile
    $('btnUseSelected').onclick = () => { if (selectedHex) $('areaCell').value = selectedHex; };
    $('btnSaveProfile').onclick = async () => {
      const area_h3 = $('areaCell').value.trim();
      const group_size = Number($('groupSize').value);
      const r = await fetch('/api/user/update', {
        method:'POST', headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ area_h3, group_size })
      });
      const out = await r.json();
      set('profileMsg', out.ok ? 'Profile saved' : 'Failed: '+(out.message||'unknown'));
      if (out.ok) { currentArea = area_h3; await loadAggregates(); await refreshChat(); }
    };

    // add point
    $('btnAdd').onclick = async () => {
      if (!selectedHex) return;
      const value = Number($('valInput').value);
      if (!Number.isFinite(value)) { alert('Enter a numeric value'); return; }
      const r = await fetch('/api/map/points-insert', {
        method:'POST', headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ cell: selectedHex, value })
      });
      const out = await r.json();
      if (out.ok) { set('status','Inserted'); await loadAggregates(); }
      else { set('status','Insert failed: '+(out.message||'unknown')); }
    };

    // aggregates
    async function loadAggregates() {
      layerAgg.clearLayers();
      try {
        const r = await fetch('/api/map/area-aggregate');
        const out = await r.json();
        if (!out.ok) { set('status','Agg error: '+(out.message||'unknown')); return; }
        (out.items||[]).forEach(a => {
          const poly = hexPoly(a.h3, Math.min(0.7, 0.2 + (Number(a.units)||0)*0.02));
          poly.bindTooltip(`${a.h3}<br/>users: ${a.users}<br/>units: ${a.units}`);
          layerAgg.addLayer(poly);
        });
      } catch(e) { set('status','Agg error: '+e.message); }
    }

    // chat
    async function refreshChat() {
      if (!currentArea || !currentUid) { $('chatList').innerHTML=''; show('badge', false); return; }
      try {
        const r = await fetch(`/api/chat/list?area=${encodeURIComponent(currentArea)}&limit=100`);
        const out = await r.json();
        if (!out.ok) { set('chatMsg','Load failed'); return; }
        $('chatList').innerHTML = (out.items||[]).map(m => (
          `<div class="msg"><div class="muted">${new Date(m.created_at).toLocaleString()}</div>${m.body}</div>`
        )).join('');
        $('chatList').scrollTop = $('chatList').scrollHeight;

        const rx = await fetch(`/api/chat/unread?area=${encodeURIComponent(currentArea)}&uid=${encodeURIComponent(currentUid)}`);
        const ux = await rx.json();
        const c = Number(ux?.count||0);
        set('badge', String(c)); show('badge', c>0);
      } catch {}
    }
    $('btnSendChat').onclick = async () => {
      if (!currentArea) { set('chatMsg','Pick & save your area first'); return; }
      const body = $('chatInput').value.trim();
      if (!body) return;
      const r = await fetch('/api/chat/seen', { // mark seen before send to keep badge sane
        method:'POST', headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ area_h3: currentArea })
      });
      void r; // ignore result
      const s = await fetch('/api/chat/post', {
        method:'POST', headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ area_h3: currentArea, body })
      });
      const out = await s.json();
      if (out.ok) { $('chatInput').value=''; await refreshChat(); }
      else set('chatMsg','Send failed: '+(out.message||'unknown'));
    };

    // init
    await refreshSessionUI();
    await loadAggregates();
    $('areaCell').addEventListener('change', () => { currentArea = $('areaCell').value.trim(); });
    setInterval(refreshChat, 8000);
  })();
  </script>
</body>
</html>
